


 
  

# Iterables

```python
iterator_obj = iter(iterable) # calls the .__iter__() method on the iterable, returning an iterator object
next(iterator_obj) # calls the .__next__() method on the iterator, when all items have been iterated, raises StopIteration exception
```

# for loops will call iter() on the iterable, and then next() until the StopIteration exception is raised

  

# Custom iterators

```python
class FishInventory:
  def __init__(self, fishList):
      self.available_fish = fishList

  def __iter__(self):
    self.index = 0
    return self

  def __next__(self):
    if self.index < len(self.available_fish):
	    fish_status = self.available_fish[self.index] + " is available!"
        self.index += 1
        return fish_status
    else:
        raise StopIteration
```

# Built-in Iterators
```python
import itertools 
```

# infinite iterators:

```python
itertools.count(start=0, step=2) # infinite counter
```

# input-dependant iterators:

```python
odd = [5, 7, 9]
even = {6, 8, 10}
all_numbers = itertools.chain(odd, even) # combines iterables into a single iterator
```
  

# combinatoric iterators:

```python
even = [2, 4, 6]
even_combinations = list(itertools.combinations(even, 2)) # all combinations of 2 even numbers as tuples
```
  

# Enumerate zip, etc

```python
for index, element in enumerate(my_list):
    pass

zip() # creates an iterator with tuples that share the same index
```

  

# Generators

# generator objects can be looped but the contents are not stored in memory

# great for complex and infinite iterations and streams of data

# Generator functions must return an iterator using yield

# Code after the yield will execute on the next iteration of the iterator

```python
def course_generator():
    yield 'Computer Science' # yield will suspend the execution and preserve local variables
    yield 'Art'
    yield 'Business'

courses = course_generator()
for course in courses:
    print(course)
```

# Generators work with next() and raise StopIteration